#!/usr/bin/env superdoit_stone
options
{
  SuperDoitOptionalOptionWithNoArg long: 'diskChanges' short: 'd'.
  SuperDoitOptionalOptionWithNoArg long: 'imageChanges' short: 'i'.
  SuperDoitOptionalOptionWithNoArg long: 'packages' short: 'p'.
  SuperDoitOptionalOptionWithNoArg long: 'modified' short: 'm'.
  SuperDoitOptionalOptionWithNoArg long: 'repositories'.
  SuperDoitOptionalOptionWithRequiredArg long: 'write'.
  SuperDoitOptionalOptionWithRequiredArg long: 'repository'.
  SuperDoitOptionalOptionWithRequiredArg long: 'version'.
  SuperDoitOptionalOptionWithRequiredArg long: 'commitMessage'.
}
%
usage
-----
USAGE 
  # with GS_HOME set (<stone-name> optional if run in $GS_HOME/servers/stones/<stone-name> directory)
  $basename [--help | -h] [--debug | -D]  [--debugGem] [-- [<stone-name> [<topaz-command-line-args>] ] ]
  # with GEMSTONE set
  $basename [--help | -h] [--debug | -D]  [--debugGem] -- (-r | -l | -L) -I <path-to-.topazini> [<topaz-command-line-args>]

DESCRIPTION
  <put your description here>

OPTIONS
  <stone-name>               Name of the GsDevKit_home stone. <stone-name> argument
                             may be skipped if the script is run in a GsDevKit_home
                             stone directory (i.e., $GS_HOME/server/stones/<stone-name>
  <topaz-command-line-args>  topaz options that should be passed to topaz when running
                             running the script
  -h, --help                 display usage message
  -D, --debug                bring up topaz debugger in the event of a script error
  --debugGem                 If terminal is connected to stdout, bring up debugger. If not,
                             dump stack to stdout and wait for topaz to attach using topaz
                             DEBUGGEM command.
  -c, --changes              Dispaly the changes for the modified Monticello packages in the image
  -p, --packages             List the Monticello packages in the image
  -m, --modified             List the modified Monticello packages in image
  --repositories         List the repositories in the image

EXAMPLES
  $basename --help                           -- gs_351             # with GS_HOME set
  $basename -h                               -- -l -I ./.topazini  # with GEMSTONE set
  $basename -D <script-arguments>            <topaz-arguments>
  $basename --debugGem <script-arguments>    <topaz-arguments>
  $basename --packages -- -I ./.topazini			# DataCurator login
  $basename --modified -- -I ./.topazini	# DataCurator login
  $basename --changes -- -I ./.topazini	# DataCurator login
  # in directory containing a .topazini
  $basename --packages
  $basename --modified
  $basename --imageChanges
  $basename --diskChanges
  $basename --repositories
  $basename --repositories --packages
  $basename --repositories --modified
  $basename --repository=bosch:/bosch1/users/dhenrich/_stones/repo \
            --write=ConfigurationOfGsOB --version=ConfigurationOfGsOB.dkh.98 \
            --commitMessage='testing the MCPackageBrowser.stone --write option'
  $basename --repository=bosch:/bosch1/users/dhenrich/_stones/repo \
            --write=ConfigurationOfGsOB --commitMessage='testing the MCPackageBrowser.stone --write option'
modifications
-----
%
method
modifiedPackages
	"return a modified Monticello packages in the image"
	^ MCWorkingCopy allManagers select: [:wc | wc modified ]
%
method
modifiedPackageNames
	"return a list of the modified Monticello package names in the image"
	^ (self modifiedPackages collect: [:wc | wc packageName ]) sort.
%
method
packageNames
	"return a list of the loaded Monticello package names in the image"
	^ (MCWorkingCopy allManagers collect: [:wc | wc packageName ]) sort.
%
method
listNames: names
	names do: [:name | 	self stdout nextPutAll: name; lf ]
%
method
listPackageNames
	self listNames: self packageNames.
	^ self noResult
%
method
listModifiedPackageNames
	self listNames: self modifiedPackageNames.
	^ self noResult
%
method
changesForWorkingCopy: wc indent: indent
	| patch |
	patch := 	wc invertedChangesRelativeToRepository: wc repositoryGroup repositories first.
	indent timesRepeat: [ self stdout nextPutAll: '    ' ].
	self stdout nextPutAll: wc packageName; lf.
	patch operations asArray sort do: [:op |
		(indent + 1) timesRepeat: [ self stdout nextPutAll: '    ' ].
		self stdout nextPutAll: op summary.
		op isAddition
			ifTrue: [ self stdout nextPutAll: ' (Addition)'; lf ]
			ifFalse: [ 
				op isRemoval
					ifTrue: [ self stdout nextPutAll: ' (Removal)'; lf ]
					ifFalse: [ self stdout nextPutAll: ' (Modification)'; lf ] ] ].
%
method
showChanges
	"inverted diffs describe changes in image relative to disk (outgoing changes), whereas, 
		non-inverted diffs discribe changes on disk relative to image (incoming changes."

	self modifiedPackages do: [:wc |
	 self changesForWorkingCopy: wc indent: 0].
	^ self noResult
%
method
listRepositories
	| packageRepos descriptions listPackages modifications packages |
	listPackages := self packages.
	packageRepos := Set new.
	descriptions := Set new.
	(Rowan globalNamed: 'MCWorkingCopy') allManagers do: [:wc |
		self modified
			ifTrue: [
				modifications ifNil: [ modifications := Dictionary new ].
				wc modified
					ifTrue: [ 
						wc repositoryGroup repositories
							do: [:repos | 
								(modifications at: repos description ifAbsentPut: [ Set new ])
									add: wc ] ] ]
			ifFalse: [ 
				self packages
					ifTrue: [
						packages ifNil: [ packages := Dictionary new ].
						wc repositoryGroup repositories
							do: [:repos | 
								repos description ~= 'cache'
									ifTrue: [ 
										(packages at: repos description ifAbsentPut: [ Set new ])
											add: wc ] ] ]
					ifFalse: [ 
						packageRepos addAll: wc repositoryGroup repositories.
						packageRepos do: [:repos | descriptions add: repos description ] ] ] ].
	modifications 
		ifNil: [
			packages 
				ifNil: [ 
					descriptions asArray sort
						do: [:repositoryDescription | 
							self stdout nextPutAll: repositoryDescription; lf ] ]
				ifNotNil: [
					packages
						keysAndValuesDo: [ :reposDescription :thePackages |
							thePackages isEmpty
								ifFalse: [ 
									self stdout nextPutAll: reposDescription; lf.
									(thePackages asArray collect: 
										[:each | each packageName ])sort 
											do: [:pName |
												self stdout nextPutAll: '    ', pName; lf ] ] ] ] ]
		ifNotNil: [ 
			modifications 
				keysAndValuesDo: [ :reposDescription :modifiedPackages |
					self stdout nextPutAll: reposDescription; lf.
					modifiedPackages do: [:wc |
						self changesForWorkingCopy: wc indent: 1 ] ] ].
	^self noResult
%
method
packageNamed: packageName
	"return a list of the loaded Monticello package names in the image"
	| col |
	col := MCWorkingCopy allManagers select: [:wc | wc packageName = packageName ].
	col isEmpty ifTrue: [ ^ nil ].
	^ col first
%
method
writePackage: packageName
	| repositoryDescription versionName version commitComment wc repository |
	wc := (self packageNamed: packageName) ifNil: [ ^ 'No package named ', packageName printString, ' found.' ].
	repositoryDescription := self repository ifNil: [ ^ 'Missing required argument ''repository''' ].
	repository := wc repositoryGroup repositories 
		detect: [:each | 
			each description ~= 'cache' and: [ each description = repositoryDescription ] ].
	commitComment := self commitMessage ifNil: [ ^ 'Missing required argument ''commitMessage''' ].
	versionName := self version 
		ifNil: [ wc uniqueVersionName ].
	version := wc 
		newVersionWithName: versionName
		message: commitComment.
	repository storeVersion: version.
	^self noResult
%
doit
	self write ifNotNil: [:packageName | ^ self writePackage: packageName ].
	self repositories ifTrue: [ ^ self listRepositories ].
	self packages ifTrue: [ ^ self listPackageNames ].
	self modified ifTrue: [ ^ self listModifiedPackageNames ].
	(self imageChanges and: [ self diskChanges ])
		ifTrue: [ self error: 'Only one of --imageChanges and --diskChanages should be used' ].
	self imageChanges ifTrue: [ ^ self showChanges ].
	self diskChanges ifTrue: [ ^ self showChanges ].
	^ 'no command selected'
%
